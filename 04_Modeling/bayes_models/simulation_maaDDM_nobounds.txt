#maaDDM simulation
model {
	##########################
	# model the data
	##########################

	#JAGS for loop specifies the distributional assumptions for the variable that is defined within its body
	for (i in 1:N) {

		#specify parameters depending on sessions
		weight1[i] <- w1T[Subject[i]]*equals(Session[i],1) + w1T_AT[Subject[i]]*equals(Session[i],2)
		weight2[i] <- w2T[Subject[i]]*equals(Session[i],1) + w2T_AT[Subject[i]]*equals(Session[i],2)
		weight3[i] <- w3T[Subject[i]]*equals(Session[i],1) + w3T_AT[Subject[i]]*equals(Session[i],2)

		theta_x[i] <- thetaT[Subject[i]]*equals(Session[i],1) + thetaT_AT[Subject[i]]*equals(Session[i],2)

		phi_x[i] <- phiT[Subject[i]]*equals(Session[i],1) + phiT_AT[Subject[i]]*equals(Session[i],2)

		alpha_x[i] <- alpha[Subject[i]]*equals(Session[i],1) + alpha_AT[Subject[i]]*equals(Session[i],2)

		scaling_x[i] <- scaling[Subject[i]]*equals(Session[i],1) + scaling_AT[Subject[i]]*equals(Session[i],2)

		tau_x[i] <- tau[Subject[i]]*equals(Session[i],1) + tau_AT[Subject[i]]*equals(Session[i],2)
		
		sp_x[i] <- sp[Subject[i]]*equals(Session[i],1) + sp_AT[Subject[i]]*equals(Session[i],2)


		#calculate mean drift rate mu
		mu[i] <- 	fixProps_Price_Eco[i]*(weight1[i]*(Price_Eco[i]-theta_x[i]*Price_NonEco[i]) + weight2[i]*phi_x[i]*(Energy_Eco[i]-theta_x[i]*Energy_NonEco[i]) + weight3[i]*phi_x[i]*(Popularity_Eco[i]-theta_x[i]*Popularity_NonEco[i])) + # Price_Eco is looked at
                		fixProps_Energy_Eco[i]*(weight1[i]*phi_x[i]*(Price_Eco[i]-theta_x[i]*Price_NonEco[i]) + weight2[i]*(Energy_Eco[i]-theta_x[i]*Energy_NonEco[i]) + weight3[i]*phi_x[i]*(Popularity_Eco[i]-theta_x[i]*Popularity_NonEco[i])) + # Consumption_Eco is looked at
                		fixProps_Popularity_Eco[i]*(weight1[i]*phi_x[i]*(Price_Eco[i]-theta_x[i]*Price_NonEco[i]) + weight2[i]*phi_x[i]*(Energy_Eco[i]-theta_x[i]*Energy_NonEco[i]) + weight3[i]*(Popularity_Eco[i]-theta_x[i]*Popularity_NonEco[i])) + # Popularity_Eco is looked at
                		fixProps_Price_NonEco[i]*(weight1[i]*(theta_x[i]*Price_Eco[i]-Price_NonEco[i]) + weight2[i]*phi_x[i]*(theta_x[i]*Energy_Eco[i]-Energy_NonEco[i]) + weight3[i]*phi_x[i]*(theta_x[i]*Popularity_Eco[i]-Popularity_NonEco[i])) + # Price_NonEco is looked at
                		fixProps_Energy_NonEco[i]*(weight1[i]*phi_x[i]*(theta_x[i]*Price_Eco[i]-Price_NonEco[i]) + weight2[i]*(theta_x[i]*Energy_Eco[i]-Energy_NonEco[i]) + weight3[i]*phi_x[i]*(theta_x[i]*Popularity_Eco[i]-Popularity_NonEco[i])) + # Consumption_NonEco is looked at
                		fixProps_Popularity_NonEco[i]*(weight1[i]*phi_x[i]*(theta_x[i]*Price_Eco[i]-Price_NonEco[i]) + weight2[i]*phi_x[i]*(theta_x[i]*Energy_Eco[i]-Energy_NonEco[i]) + weight3[i]*(theta_x[i]*Popularity_Eco[i]-Popularity_NonEco[i]))   # Popularity_NonEco is looked at
		
		#draw from wiener distribution
		x[i] ~ dwiener(alpha_x[i], tau_x[i], sp_x[i], scaling_x[i] * mu[i])
	}

	##########################
	# priors for parameters
	##########################

	# Define group priors


		# boundary
			mu_alpha ~ dnorm(8,1)
			sigma_alpha ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_alpha <- 1/pow(sigma_alpha, 2)

		# non-decision time
			mu_tau ~ dnorm(1, 1)
			sigma_tau ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_tau <- 1/pow(sigma_tau, 2)

		# scaling
			mu_scaling ~ dnorm(1, 1)
			sigma_scaling ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_scaling <- 1/pow(sigma_scaling, 2)


		# theta
			mu_theta ~ dnorm(0.5, 1)
			sigma_theta ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_theta <- 1/pow(sigma_theta, 2)

		# phi
			mu_phi ~ dnorm(0.5, 1)
			sigma_phi ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_phi <- 1/pow(sigma_phi, 2)

		# weights
			mu_w1 ~ dnorm(0, 1)
			sigma_w1 ~ dnorm(1,1)T(0,)
		
			# transform SD to precision
			lambda_w1 <- 1/pow(sigma_w1, 2)
	
			mu_w2 ~ dnorm(0, 1)
			sigma_w2 ~ dnorm(1,1)T(0,)
		
			# transform SD to precision
			lambda_w2 <- 1/pow(sigma_w2, 2)

		# starting point
			mu_sp ~ dnorm(1/2, 1)
			sigma_sp ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_sp <- 1/pow(sigma_sp, 2)


		
		# -----------------
		# Manipulation Session
		# -----------------

		# weights change parameters
			
			mu_dw1 ~ dnorm(0, 1)
			sigma_dw1 ~  dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dw1 <- 1/pow(sigma_dw1, 2)

			mu_dw2 ~ dnorm(0, 1)
			sigma_dw2 ~  dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dw2 <- 1/pow(sigma_dw2, 2)

		# theta change parameter
		
			mu_dtheta ~ dnorm(0, 1)
			sigma_dtheta ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dtheta <- 1/pow(sigma_dtheta, 2)

		# phi change parameter
		
			mu_dphi ~ dnorm(0, 1)
			sigma_dphi ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dphi <- 1/pow(sigma_dphi, 2)

		# boundary change parameter
			
			mu_dalpha ~ dnorm(0, 1)
			sigma_dalpha ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dalpha <- 1/pow(sigma_dalpha, 2)

		# scaling change parameter
		
			mu_dscaling ~ dnorm(0,1)
			sigma_dscaling ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dscaling <- 1/pow(sigma_dscaling, 2)

		# tau change parameter
	
			mu_dtau ~ dnorm(0,1)
			sigma_dtau ~ dnorm(1,1)T(0,)

			# transform SD to precision
			lambda_dtau <- 1/pow(sigma_dtau, 2)

		# starting point change parameter
		
			mu_dsp ~ dnorm(0, 1)
			sigma_dsp ~ dnorm(1, 1)T(0,)

			# transform SD to precision
			lambda_dsp <- 1/pow(sigma_dsp, 2)


	
}